#region Prolog


#################################################################
## IBM Confidential
##
## OCO Source Materials
##
## BI and PM: pmpsvc
##
## (C) Copyright IBM Corp. 2008, 2009, 2010
##
## The source code for this program is not published or otherwise
## divested of its trade secrets, irrespective of what has been
## deposited with the U.S. Copyright Office.
#################################################################

#*** Log File Name
cConfigDim = '}tp_config';
If (DimensionExists(cConfigDim) = 1);
	cGenerateLog = ATTRS(cConfigDim, 'Generate TI Log', 'String Value');
Else;
	cGenerateLog = 'N';
EndIf;

cTM1Process = GetProcessName();
StringGlobalVariable('gPrologLog');
StringGlobalVariable('gEpilogLog');
StringGlobalVariable('gDataLog');

IF (cGenerateLog @= 'Y' % cGenerateLog @= 'T');
vReturnValue = ExecuteProcess('}tp_get_log_file_names', 'pExecutionId', pExecutionId,
'pProcess', cTM1Process, 'pControl', 'Y');
If (vReturnValue <> ProcessExitNormal());
	ProcessError;
EndIf;
Endif;

cPrologLog = gPrologLog;
cEpilogLog = gEpilogLog;
cDataLog = gDataLog;
cTM1Log = cPrologLog;

#*** Log Parameters

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Parameters:',pExecutionId, pAppId, pCube,pApprovalDim, pUpdateSubset, pVersionDim, pVersionSlicesWrite, pVersionSlicesRead);
EndIf;

#***
vCellSecurityPermissionCube = '}CellSecurity_}tp_application_permission}' | pAppId;
cIMRDCLSCube = '}tp_intermediate_RDCLS}' | pCube;
cCellSecurityCube = '}CellSecurity_' | pCube;
cAllApplications = 'all_applications';
vIncrGroupDim = 'tp_incr_temp_groups_' | pAppId;

#***
IF (CubeExists(cIMRDCLSCube) >0);

#***
cGroupsDim = '}Groups';
IF (pIncremental @= 'Y');
	cGroupsDim = vIncrGroupDim;
Endif;

#***
versionIndex = 0;
approvalIndex = 0;
dimensionIndex = 1;
While (dimensionIndex > 0 ); 
	cCubeDimensionName = TABDIM(pCube, dimensionIndex);
	If (cCubeDimensionName @= '');
		dimensionIndex = -1;
	Else;
		IF (cCubeDimensionName @=pVersionDim);
			versionIndex = dimensionIndex;
		Endif;
				
		IF (cCubeDimensionName @= pApprovalDim );
			approvalIndex =dimensionIndex ;
		Endif;

	EndIf;

	dimensionIndex = dimensionIndex + 1;
End;

IF (versionIndex < approvalIndex);
	versionFirst = 'Y';
Endif;

#*Update Intermediate cell security cube
IF (pUpdateIntermediateSecurity @= 'Y');

	vTotalGroups = DIMSIZ(cGroupsDim);
	vGroupLooper = 1;
	While (vGroupLooper <= vTotalGroups);
		vGroup = DIMNM(cGroupsDim, vGroupLooper);
		vTotalNodes = SubsetGetSize(pApprovalDim, pUpdateSubset);
		vNodeLooper = 1;
		While (vNodeLooper <= vTotalNodes);
			vApprovalNode = SubsetGetElementName(pApprovalDim, pUpdateSubset, vNodeLooper);
			vView = CellGetS(vCellSecurityPermissionCube, vApprovalNode, 'VIEW', vGroup);
			vEdit = CellGetS(vCellSecurityPermissionCube, vApprovalNode, 'EDIT', vGroup);
			vNodeSecurity = '';
			vVersionSecurity = '';
			vFinalSecurity = '';
			IF (vView @= 'READ');
				IF (DType(pApprovalDim, vApprovalNode) @='C');
					vNodeSecurity = 'WRITE';
				Else;
					vNodeSecurity = 'READ';
				Endif;
			Endif;

			IF (vEdit @= 'READ');
				vNodeSecurity = 'WRITE';
			Endif;
							
			IF (vNodeSecurity @<> '');

			#***readable version slices
			versionSeparater = '|';
			vPosVersion = 0;
			vStringToScan = pVersionSlicesRead;
			IF (pVersionSlicesRead @<> '');
				vPosVersion = SCAN(versionSeparater, vStringToScan);
			Else;
				#Even no readable version slices are defined, we still need to apply security
				#based on approval dimension
				vPosVersion = 1;
			Endif;

			While (vPosVersion >0);
				vVersionSlice  = SUBST(vStringToScan, 1, vPosVersion-1);
				vStringToScan = SUBST(vStringToScan, vPosVersion +1, LONG(vStringToScan)-vPosVersion);
				vPosVersion = SCAN(versionSeparater, vStringToScan);

				IF (versionIndex >0);
					IF (vVersionSlice @<> '' );
						IF (DIMIX(pVersionDim, vVersionSlice)=0);
							vReturnValue = ExecuteProcess('}tp_error_update_error_cube',
								'pGuid', pExecutionId,
								'pProcess', cTM1Process,
								'pErrorCode', 'TI_READABLE_SLICE_NOT_EXISTS',
								'pErrorDetails', pVersionDim  | '.' | vVersionSlice | ', ' |  pAppId,
								'pControl', 'Y');
	
								ProcessError;
						Endif;

						IF (approvalIndex >0);
							IF (versionFirst @= 'Y');
								CellPutS('READ', cIMRDCLSCube, vVersionSlice, vApprovalNode,pAppId, vGroup,'Rights' );
							Else;
								CellPutS('READ', cIMRDCLSCube, vApprovalNode, vVersionSlice,pAppId, vGroup,'Rights' );
							Endif;
						Else;
							CellPutS('READ', cIMRDCLSCube, vVersionSlice, pAppId, vGroup,'Rights' );	
						Endif;
					Endif;

				ElseIf (versionIndex = 0 & approvalIndex >0);
					CellPutS('READ', cIMRDCLSCube, vApprovalNode, pAppId, vGroup,'Rights' );
				Endif;

			End;

			#***writable version slices
			versionSeparater = '|';
			vPosVersion = 0;
			vStringToScan = pVersionSlicesWrite;
			IF (pVersionSlicesWrite @<> '');
				vPosVersion = SCAN(versionSeparater, vStringToScan);
			Else;
				#Even no writable version slices are defined, we still need to apply security
				#based on approval dimension
				vPosVersion = 1;
			Endif;

			While (vPosVersion >0);
				vVersionSlice  = SUBST(vStringToScan, 1, vPosVersion-1);
				vStringToScan = SUBST(vStringToScan, vPosVersion +1, LONG(vStringToScan)-vPosVersion);
				vPosVersion = SCAN(versionSeparater, vStringToScan);
				IF (vNodeSecurity @= 'READ');
					vFinalSecurity = 'READ';
				Elseif (vNodeSecurity @= 'WRITE');
					vFinalSecurity = 'WRITE';
				Endif;
	
				IF (versionIndex >0);
					IF (vVersionSlice @<>'');
						IF (DIMIX(pVersionDim, vVersionSlice)=0);
							vReturnValue = ExecuteProcess('}tp_error_update_error_cube',
								'pGuid', pExecutionId,
								'pProcess', cTM1Process,
								'pErrorCode', 'TI_WRITABLE_SLICE_NOT_EXISTS',
								'pErrorDetails', pVersionDim  | '.' | vVersionSlice | ', ' |  pAppId,
								'pControl', 'Y');
	
								ProcessError;
						Endif;

						IF (approvalIndex >0);
							IF (versionFirst @= 'Y');
								CellPutS(vFinalSecurity, cIMRDCLSCube, vVersionSlice, vApprovalNode,pAppId, vGroup,'Rights' );
							Else;
								CellPutS(vFinalSecurity, cIMRDCLSCube, vApprovalNode, vVersionSlice,pAppId, vGroup,'Rights' );
							Endif;
						Else;
							CellPutS(vFinalSecurity, cIMRDCLSCube, vVersionSlice, pAppId, vGroup,'Rights' );
						Endif;
					Endif;

				ElseIf (versionIndex = 0 & approvalIndex >0);
					CellPutS(vFinalSecurity, cIMRDCLSCube, vApprovalNode, pAppId, vGroup,'Rights' );
				Endif;
			End;
			Endif;

			vNodeLooper = vNodeLooper  +1;
		End;
		vGroupLooper = vGroupLooper +1;
	End;

Endif;

Endif;

#endregion
#region Epilog


#################################################################
## IBM Confidential
##
## OCO Source Materials
##
## BI and PM: pmpsvc
##
## (C) Copyright IBM Corp. 2008, 2009, 2010
##
## The source code for this program is not published or otherwise
## divested of its trade secrets, irrespective of what has been
## deposited with the U.S. Copyright Office.
#################################################################

#*Update RD cell security cubes
IF (CubeExists(cIMRDCLSCube) >0);
vTotalGroups = DIMSIZ(cGroupsDim);
vGroupLooper = 1;
While (vGroupLooper <= vTotalGroups);
	vGroup = DIMNM(cGroupsDim, vGroupLooper);

	vTotalNodes = SubsetGetSize(pApprovalDim, pUpdateSubset);
	vNodeLooper = 1;
	While (vNodeLooper <= vTotalNodes);
		vApprovalNode = SubsetGetElementName(pApprovalDim, pUpdateSubset, vNodeLooper);
		vFinalCellSecurity ='NONE';

		IF (versionIndex >0);
			vTotalVersions = DIMSIZ(pVersionDim);
			vVersionLooper = 1;
			While (vVersionLooper <= vTotalVersions);
				vVersion = DIMNM(pVersionDim, vVersionLooper);
				IF (approvalIndex >0)	;	
					IF (versionFirst @= 'Y');
						vFinalCellSecurity=CellGetS(cIMRDCLSCube, vVersion, vApprovalNode,cAllApplications, vGroup,'Rights' );
						vCurrentCellSecurity = CellGetS(cIMRDCLSCube, vVersion, vApprovalNode,cAllApplications, vGroup,'StaticRights');
						IF (vFinalCellSecurity @<> vCurrentCellSecurity);
							CellPutS(vFinalCellSecurity, cIMRDCLSCube, vVersion, vApprovalNode,cAllApplications, vGroup,'StaticRights');
						Endif;
						
					Else;
						vFinalCellSecurity=CellGetS(cIMRDCLSCube, vApprovalNode, vVersion,cAllApplications, vGroup,'Rights' );
						vCurrentCellSecurity = CellGetS(cIMRDCLSCube, vApprovalNode, vVersion,cAllApplications, vGroup,'StaticRights');
						IF (vFinalCellSecurity @<> vCurrentCellSecurity);
							CellPutS(vFinalCellSecurity, cIMRDCLSCube, vApprovalNode, vVersion,cAllApplications, vGroup,'StaticRights');
						Endif;
					Endif;
				Else;
					vFinalCellSecurity=CellGetS(cIMRDCLSCube,vVersion, cAllApplications, vGroup,'Rights' );
					vCurrentCellSecurity = CellGetS(cIMRDCLSCube,vVersion, cAllApplications, vGroup,'StaticRights' );
					IF (vFinalCellSecurity @<>vCurrentCellSecurity);
						CellPutS(vFinalCellSecurity, cIMRDCLSCube,vVersion, cAllApplications, vGroup,'StaticRights');
					Endif;
				Endif;
				vVersionLooper = vVersionLooper +1;
			End;

		ElseIf (versionIndex = 0 & approvalIndex >0);
			vFinalCellSecurity=CellGetS(cIMRDCLSCube,vApprovalNode, cAllApplications, vGroup,'Rights' );
			vCurrentCellSecurity = CellGetS(cIMRDCLSCube,vApprovalNode, cAllApplications, vGroup,'StaticRights');
			IF (vFinalCellSecurity @<>vCurrentCellSecurity);
				CellPutS(vFinalCellSecurity, cIMRDCLSCube,vApprovalNode, cAllApplications, vGroup,'StaticRights');
			Endif;
		Endif;
		vNodeLooper = vNodeLooper  +1;		
	End;
	vGroupLooper = vGroupLooper +1;
End;

Endif;

#endregion